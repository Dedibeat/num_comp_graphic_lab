#include <GL/glut.h>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <ctime>
#include<iostream>
#include"geo.h"
using namespace std;
// Window size
const int WIDTH = 1000;
const int HEIGHT = 800;


// Snake parameters
std::vector<point2d> snake;
int snakeLength = 2;       // initial length of snake segments
float snakeNonBoostSpeed = 2.0f;    // speed of snake head movement
float snakeSpeed = 2.0f;
float snakeBoostSpeed = 3.5f;
float segmentSpacing = 10.0f; // distance between snake segments
float bodyRadius = 5.0f;
float RadPerFood = 0.05f;
int SegmentPerFood = 1;
float ChanceOfFoodSpawningEveryFrame = 20;
int LookatX = 1000,LookatY = 1000;
int BorderX = 2000,BorderY = 2000;
point2d Facing;

// Mouse position
point2d mouse(WIDTH/2,HEIGHT/2);

// Food
struct Food {
    float x, y;bool eaten;
};
std::vector<Food> foods;
int maxFood = 100;
int FoodNumber = 10;
float foodRadius = 5.0f;

double toDeg(double radian){
    return radian * 180.0 / PI;
}
double toRad(double degrees){
    return degrees / PI * 180.0;
}
point2d rotatePoint(float angle, const point2d& p) {
    angle = toRad(angle);
    float rotatedX = p.x * cos(angle) - p.y * sin(angle);
    float rotatedY = p.x * sin(angle) + p.y * cos(angle);
    return {rotatedX, rotatedY};
}

// Utility functions
float distanceBetween(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return std::sqrt(dx * dx + dy * dy);
}

void placeFoods() {
    foods.clear();
    for (int i = 0; i < maxFood; i++) {
        Food f;
        f.x = rand() % BorderX;
        f.y = rand() % BorderY;
        f.eaten = false;
        foods.push_back(f);
    }
}

void GenerateFood() {
    if(FoodNumber < maxFood){
        FoodNumber++;
        Food f;
        f.x = rand() % BorderX;
        f.y = rand() % BorderY;
        f.eaten = false;
        foods.push_back(f);
    }
}

// Initialize snake
void initSnake() {
    snake.clear();
    // Place snake in middle

    for (int i = 0; i < snakeLength; i++) {
        point2d s;
        s.x = WIDTH / 2.0f;
        s.y = HEIGHT / 2.0f - i * segmentSpacing;
        snake.push_back(s);
    }
}

// Draw a filled circle
void drawCircle(float cx, float cy, float r) {
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(cx, cy);
    float red = 1.f, gr = 1.f, bl  = 1.f;
    for (int i = 0; i <= 32; i++) {
        glColor3f(red = red - 0.02f, gr = gr - 0.02f, bl = bl - 0.02f);
        float theta = 2.0f * 3.1415926f * float(i) / 32.0f;
        float x = r * cosf(theta);
        float y = r * sinf(theta);
        glVertex2f(cx + x, cy + y);
    }
    glEnd();
}

void UpdateFacing(){
    Facing = snake[0] - snake[1];
    Facing /= abs_val(Facing);
    point2d ToMouse(mouse.x - WIDTH/2, mouse.y - HEIGHT/2);
    ToMouse /= abs_val(ToMouse);
    double crossProd = cross(Facing,ToMouse);
    double theta = angle(Facing,ToMouse);
    if(toDeg(theta) > 5){
        if(crossProd > 0){
            Facing = rotatePoint(0.01,Facing);
        } else Facing = rotatePoint(-0.01,Facing);
    }
}

// Update snake position
void updateSnake() {

    // Move head towards mouse
    UpdateFacing();

    float dx = Facing.x;
    float dy = Facing.y;
    float dist = std::sqrt(dx*dx + dy*dy);
    if (dist > 0.001f) {
        float vx = (dx / dist) * snakeSpeed;
        float vy = (dy / dist) * snakeSpeed;
        // Move head
        snake[0].x += vx;
        snake[0].y += vy;
    }

    // Move other segments to follow the head

    for (int i = 1; i < (int)snake.size(); i++) {
        float prevX = snake[i-1].x;
        float prevY = snake[i-1].y;
        float curX = snake[i].x;
        float curY = snake[i].y;
        float distSeg = distanceBetween(prevX, prevY, curX, curY);
        if (distSeg > segmentSpacing) {
            float angle = atan2(prevY - curY, prevX - curX);
            snake[i].x = prevX - cos(angle) * segmentSpacing;
            snake[i].y = prevY - sin(angle) * segmentSpacing;
        }
    }


    // Check for food collision
    float headRadius = bodyRadius;
    for (auto &f : foods) {
        if (!f.eaten) {
            float d = distanceBetween(snake[0].x, snake[0].y, f.x, f.y);
            if (d < headRadius + foodRadius) {
                f.eaten = true;
                bodyRadius += RadPerFood;
                segmentSpacing += RadPerFood;
                FoodNumber--;
                // Grow snake
                for (int i = 0; i < SegmentPerFood; i++) { // add 5 segments per food
                    point2d s = snake.back();
                    snake.push_back(s);
                }
            }
        }
    }
    //  Generating food
    if(rand()%100 + 1 < ChanceOfFoodSpawningEveryFrame){
        GenerateFood();
    }
}

void handleKeypress(unsigned char key, int x, int y) {;
    // Exit the program if the user presses 'q'
    if (key == 'q' || key == 'Q') {
        exit(0);
    }
    // Boost Mechanic
    if(key == 32){
        if(snakeSpeed == snakeNonBoostSpeed) snakeSpeed = snakeBoostSpeed;
        else snakeSpeed = snakeNonBoostSpeed;
    }
}

// Display function
void display() {


    glClear(GL_COLOR_BUFFER_BIT);

    //Center Camera
    const auto &head = snake[0];
    glMatrixMode(GL_PROJECTION);

    glLoadIdentity();
    gluOrtho2D(head.x - (LookatX / 2), head.x + (LookatX / 2),
               head.y - (LookatY / 2), head.y + (LookatY / 2));
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // Draw snake
    glColor3f(0.0f, 1.0f, 0.0f);
    for (auto &seg : snake) {
        drawCircle(seg.x, seg.y, bodyRadius);
    }

    // Draw food
    for (auto &f : foods) {
        if (!f.eaten) {
            glColor3f(1.0f, 0.0f, 0.0f);
            drawCircle(f.x, f.y, foodRadius);
        }
    }

    glutSwapBuffers();
}
// Passive mouse motion
void passiveMotion(int x, int y) {
    mouse.x = x;
    mouse.y = HEIGHT - y; // flip y since OpenGL's origin is bottom-left
}

// Timer for updates
void timer(int value) {
    updateSnake();
    glutPostRedisplay();
    glutTimerFunc(16, timer, 0); // ~60 FPS
}

void reshape(int w, int h) {
    glViewport(0, 0, w, h);
    const auto &head = snake[0];
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(head.x - WIDTH / 2.0f, head.x + WIDTH / 2.0f,
               head.y - HEIGHT / 2.0f, head.y + HEIGHT / 2.0f);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

// Main
int main(int argc, char** argv) {
    srand((unsigned int)time(NULL));
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(WIDTH, HEIGHT);
    glutCreateWindow("Single Snake (Slither.io-like) Demo");

    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);

    initSnake();
    placeFoods();

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(handleKeypress);
    glutPassiveMotionFunc(passiveMotion);
    glutTimerFunc(16, timer, 0);

    glutMainLoop();
    return 0;
}
